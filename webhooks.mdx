---
title: "Webhooks"
description: "Receive real-time notifications when wallet transactions occur â€” no polling required."
---

Zerion webhooks let you subscribe to wallet activity across any supported chain. When a transaction is detected, Zerion sends a POST request to your callback URL with the full transaction data.

## How it works

<Steps>
  <Step title="Create a subscription">
    Register a webhook by specifying the wallets you want to monitor, the chains to watch, and your callback URL.
  </Step>
  <Step title="Receive notifications">
    When a transaction is detected for any watched wallet, Zerion sends a POST request to your callback URL with the parsed transaction data.
  </Step>
  <Step title="Process the event">
    Your server receives the webhook payload, verifies it, and processes the transaction data.
  </Step>
</Steps>

## Create a subscription

<CodeGroup>

```bash cURL
curl -u "YOUR_API_KEY:" \
  -X POST "https://api.zerion.io/v1/tx-subscriptions/" \
  -H "Content-Type: application/json" \
  -d '{
    "data": {
      "type": "tx-subscriptions",
      "attributes": {
        "webhook_url": "https://your-app.com/webhooks/zerion",
        "chain_ids": ["ethereum", "base", "optimism"],
        "addresses": [
          "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045",
          "0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B"
        ]
      }
    }
  }'
```

```javascript JavaScript
const apiKey = "YOUR_API_KEY";

const response = await fetch("https://api.zerion.io/v1/tx-subscriptions/", {
  method: "POST",
  headers: {
    Authorization: `Basic ${btoa(`${apiKey}:`)}`,
    "Content-Type": "application/json"
  },
  body: JSON.stringify({
    data: {
      type: "tx-subscriptions",
      attributes: {
        webhook_url: "https://your-app.com/webhooks/zerion",
        chain_ids: ["ethereum", "base", "optimism"],
        addresses: [
          "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045",
          "0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B"
        ]
      }
    }
  })
});

const data = await response.json();
console.log(`Subscription ID: ${data.data.id}`);
```

```python Python
import requests

api_key = "YOUR_API_KEY"

response = requests.post(
    "https://api.zerion.io/v1/tx-subscriptions/",
    auth=(api_key, ""),
    json={
        "data": {
            "type": "tx-subscriptions",
            "attributes": {
                "webhook_url": "https://your-app.com/webhooks/zerion",
                "chain_ids": ["ethereum", "base", "optimism"],
                "addresses": [
                    "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045",
                    "0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B"
                ]
            }
        }
    }
)

data = response.json()
print(f"Subscription ID: {data['data']['id']}")
```

</CodeGroup>

## Webhook payload

When a transaction is detected, Zerion sends a POST request to your callback URL. The payload contains the full parsed transaction, identical to what the transactions endpoint returns.

```json Example webhook payload
{
  "data": {
    "type": "transactions",
    "id": "0xabc123...",
    "attributes": {
      "operation_type": "trade",
      "hash": "0xabc123...",
      "mined_at": "2025-01-15T12:30:00Z",
      "status": "confirmed",
      "nonce": 42,
      "fee": {
        "fungible_info": {
          "name": "Ethereum",
          "symbol": "ETH"
        },
        "quantity": {
          "float": 0.003
        },
        "value": 8.50
      },
      "transfers": [
        {
          "direction": "out",
          "fungible_info": {
            "name": "USD Coin",
            "symbol": "USDC"
          },
          "quantity": { "float": 1000.0 },
          "value": 1000.0
        },
        {
          "direction": "in",
          "fungible_info": {
            "name": "Ethereum",
            "symbol": "ETH"
          },
          "quantity": { "float": 0.5 },
          "value": 1000.0
        }
      ]
    }
  }
}
```

Your server should return a `200` status code to acknowledge receipt. If Zerion receives a non-2xx response, the delivery will be retried.

## Managing subscriptions

Once a subscription is created, you can manage it through the API:

| Action | Method | Endpoint |
|--------|--------|----------|
| List subscriptions | `GET` | `/v1/tx-subscriptions/` |
| Get subscription | `GET` | `/v1/tx-subscriptions/{id}` |
| Delete subscription | `DELETE` | `/v1/tx-subscriptions/{id}` |
| Enable subscription | `POST` | `/v1/tx-subscriptions/{id}/enable` |
| Disable subscription | `POST` | `/v1/tx-subscriptions/{id}/disable` |
| Update callback URL | `PATCH` | `/v1/tx-subscriptions/{id}/callback-url` |
| Update chains | `PATCH` | `/v1/tx-subscriptions/{id}/chain-ids` |
| List wallets | `GET` | `/v1/tx-subscriptions/{id}/wallets` |
| Add/remove wallets | `PATCH` | `/v1/tx-subscriptions/{id}/wallets` |
| Replace wallets | `PUT` | `/v1/tx-subscriptions/{id}/wallets` |
| Count wallets | `GET` | `/v1/tx-subscriptions/{id}/wallets/count` |

<Tip>
You can filter subscriptions by chain using `filter[chain_ids]` on the list endpoint.
</Tip>

## Best practices

<AccordionGroup>
  <Accordion title="Use HTTPS callback URLs">
    Always use HTTPS for your webhook endpoint to ensure transaction data is encrypted in transit.
  </Accordion>
  <Accordion title="Return 200 quickly">
    Process webhook payloads asynchronously. Return a `200` immediately and handle the data in a background job to avoid timeouts.
  </Accordion>
  <Accordion title="Handle duplicate deliveries">
    Use the transaction `id` to deduplicate events. In rare cases, the same transaction may be delivered more than once.
  </Accordion>
  <Accordion title="Monitor subscription health">
    Use the enable/disable endpoints to pause subscriptions during maintenance, and check subscription status regularly.
  </Accordion>
</AccordionGroup>
